// Copyright (c) Duende Software. All rights reserved.
// See LICENSE in the project root for license information.

#nullable enable

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Duende.IdentityServer.SourceGenerators;

/// <summary>
/// Source generator that creates strongly-typed profile validators for types marked with [GenerateProfileValidator].
/// This eliminates the need for expression tree parsing and reflection at runtime.
/// </summary>
[Generator]
public class ProfileValidatorGenerator : IIncrementalGenerator
{
    private const string AttributeName = "Duende.IdentityServer.Configuration.Profiles.GenerateProfileValidatorAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all types marked with [GenerateProfileValidator]
        var typesWithAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeName,
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, _) => GetTypeToGenerate(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndTypes = context.CompilationProvider.Combine(typesWithAttribute.Collect());

        // Generate validator classes
        context.RegisterSourceOutput(compilationAndTypes, static (spc, source) => Execute(spc, source.Left, source.Right!));
    }

    private static TypeToGenerate? GetTypeToGenerate(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        return new TypeToGenerate(typeSymbol);
    }

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<TypeToGenerate?> types)
    {
        foreach (var typeToGenerate in types)
        {
            if (typeToGenerate is null)
            {
                continue;
            }

            var source = GenerateValidatorClass(typeToGenerate.TypeSymbol);
            var fileName = $"{typeToGenerate.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)).Replace(".", "_")}_ProfileValidator.g.cs";

            context.AddSource(fileName, source);
        }
    }

    private static string GenerateValidatorClass(INamedTypeSymbol typeSymbol)
    {
        var properties = GetSettableProperties(typeSymbol);
        var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
        var validatorClassName = $"{typeSymbol.Name}ProfileValidator";
        var fullTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));

        var propertyMethods = GeneratePropertyMethods(properties);

        return $$"""
            // <auto-generated />
            // Copyright (c) Duende Software. All rights reserved.
            // See LICENSE in the project root for license information.

            #nullable enable

            using Microsoft.Extensions.Logging;
            using Duende.IdentityServer.Configuration.Profiles;

            namespace {{namespaceName}};

            /// <summary>
            /// Auto-generated validator for {{typeSymbol.Name}}.
            /// Provides strongly-typed property accessors for profile validation without reflection.
            /// </summary>
            public sealed class {{validatorClassName}}
            {
                private readonly {{fullTypeName}} _instance;
                private readonly ILogger _logger;
                private readonly bool _logOverrides;

                /// <summary>
                /// Initializes a new instance of the <see cref="{{validatorClassName}}"/> class.
                /// </summary>
                public {{validatorClassName}}(
                    {{fullTypeName}} instance,
                    ILogger logger,
                    bool logOverrides)
                {
                    _instance = instance;
                    _logger = logger;
                    _logOverrides = logOverrides;
                }
            {{propertyMethods}}
            }
            """;
    }

    private static List<PropertyInfo> GetSettableProperties(INamedTypeSymbol typeSymbol)
    {
        var properties = new List<PropertyInfo>();
        var visited = new HashSet<string>();

        // Walk the type hierarchy to get all public settable properties
        WalkProperties(typeSymbol, "", properties, visited, depth: 0);

        return properties;
    }

    private static void WalkProperties(
        INamedTypeSymbol typeSymbol,
        string prefix,
        List<PropertyInfo> properties,
        HashSet<string> visited,
        int depth)
    {
        // Limit nesting depth to avoid infinite recursion
        if (depth > 3)
        {
            return;
        }

        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is not IPropertySymbol property)
            {
                continue;
            }

            if (property.SetMethod is null || property.SetMethod.DeclaredAccessibility != Accessibility.Public)
            {
                continue;
            }

            if (property.DeclaredAccessibility != Accessibility.Public)
            {
                continue;
            }

            var propertyPath = string.IsNullOrEmpty(prefix)
                ? property.Name
                : $"{prefix}.{property.Name}";

            // Avoid duplicates
            if (visited.Contains(propertyPath))
            {
                continue;
            }

            visited.Add(propertyPath);

            var accessChain = string.IsNullOrEmpty(prefix)
                ? $".{property.Name}"
                : $".{prefix}.{property.Name}";

            // Include nullability annotations in the type display string to preserve nullable reference types
            var typeDisplayFormat = SymbolDisplayFormat.FullyQualifiedFormat
                .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)
                .WithMiscellaneousOptions(
                    SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier |
                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes);

            var typeDisplayString = property.Type.ToDisplayString(typeDisplayFormat);

            properties.Add(new PropertyInfo(
                property.Name,
                propertyPath,
                typeDisplayString,
                accessChain));

            // Recursively walk nested properties if it's a class type
            if (property.Type is INamedTypeSymbol nestedType &&
                ShouldWalkNested(nestedType))
            {
                WalkProperties(nestedType, propertyPath, properties, visited, depth + 1);
            }
        }
    }

    private static bool ShouldWalkNested(INamedTypeSymbol typeSymbol)
    {
        // Don't walk into system types, collections, or other special types
        if (typeSymbol.SpecialType != SpecialType.None)
        {
            return false;
        }

        var fullName = typeSymbol.ToDisplayString();

        // Skip common framework types
        if (fullName.StartsWith("System.") ||
            fullName.StartsWith("Microsoft.") ||
            fullName.StartsWith("System.Collections"))
        {
            return false;
        }

        // Skip if it's a collection type
        if (typeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString().StartsWith("System.Collections")))
        {
            return false;
        }

        return typeSymbol.TypeKind == TypeKind.Class;
    }

    private static string GeneratePropertyMethods(List<PropertyInfo> properties)
    {
        var sb = new StringBuilder();

        foreach (var property in properties)
        {
            var methodName = SanitizeMethodName(property.PropertyPath);

            // Raw string literals don't have locale issues - the CA warning is a false positive
#pragma warning disable CA1305
            sb.Append($$"""

                    /// <summary>
                    /// Gets a validator for the {{property.PropertyPath}} property.
                    /// </summary>
                    public ProfilePropertyValidator<{{property.TypeName}}> {{methodName}}()
                    {
                        return new ProfilePropertyValidator<{{property.TypeName}}>(
                            "{{property.PropertyPath}}",
                            () => _instance{{property.AccessChain}}!,
                            value => _instance{{property.AccessChain}} = value,
                            _logger,
                            _logOverrides);
                    }
                """);
#pragma warning restore CA1305
        }

        return sb.ToString();
    }

    private static string SanitizeMethodName(string propertyPath) =>
        // Replace dots with nothing to create a valid method name
        // e.g., "Endpoints.EnableDiscoveryEndpoint" -> "EndpointsEnableDiscoveryEndpoint"
#if NET8_0_OR_GREATER
        propertyPath.Replace(".", "", StringComparison.Ordinal);
#else
        propertyPath.Replace(".", "");
#endif

    private record TypeToGenerate(INamedTypeSymbol TypeSymbol);

    private record PropertyInfo(
        string Name,
        string PropertyPath,
        string TypeName,
        string AccessChain);
}
