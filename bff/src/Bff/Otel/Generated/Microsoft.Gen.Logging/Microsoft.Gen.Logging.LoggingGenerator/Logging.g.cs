
// <auto-generated/>
#nullable enable
using Microsoft.AspNetCore.Http;

#pragma warning disable CS1591 // Compensate for https://github.com/dotnet/roslyn/issues/54103

namespace Duende.Bff.Licensing
{
    internal static class LicensingLogMessages
    {
        /// <summary>
        /// Logs "Duende BFF Security Framework License information:\r\n - Edition: {Edition}\r\n - Expiration: {ExpirationDate}\r\n - LicenseContact: {LicenseContact}\r\n - LicenseCompany: {licenseCompany}        \r\n - Number of frontends licensed: {NumberOfFrontends}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LicenseDetails(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, string? edition, global::System.DateTimeOffset? expirationDate, string licenseContact, string licenseCompany, string? numberOfFrontends)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(6);
            state.TagArray[5] = new("Edition", edition);
            state.TagArray[4] = new("ExpirationDate", expirationDate);
            state.TagArray[3] = new("LicenseContact", licenseContact);
            state.TagArray[2] = new("licenseCompany", licenseCompany);
            state.TagArray[1] = new("NumberOfFrontends", numberOfFrontends);
            state.TagArray[0] = new("{OriginalFormat}", "Duende BFF Security Framework License information:\r\n - Edition: {Edition}\r\n - Expiration: {ExpirationDate}\r\n - LicenseContact: {LicenseContact}\r\n - LicenseCompany: {licenseCompany}        \r\n - Number of frontends licensed: {NumberOfFrontends}");

            logger.Log(
                level,
                new(1205910631, nameof(LicenseDetails)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var edition = s.TagArray[5].Value ?? "(null)";
                    var expirationDate = s.TagArray[4].Value ?? "(null)";
                    var licenseContact = s.TagArray[3].Value ?? "(null)";
                    var licenseCompany = s.TagArray[2].Value ?? "(null)";
                    var numberOfFrontends = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Duende BFF Security Framework License information:\r\n - Edition: {edition}\r\n - Expiration: {expirationDate}\r\n - LicenseContact: {licenseContact}\r\n - LicenseCompany: {licenseCompany}        \r\n - Number of frontends licensed: {numberOfFrontends}");
                    #else
                    return global::System.FormattableString.Invariant($"Duende BFF Security Framework License information:\r\n - Edition: {edition}\r\n - Expiration: {expirationDate}\r\n - LicenseContact: {licenseContact}\r\n - LicenseCompany: {licenseCompany}        \r\n - Number of frontends licensed: {numberOfFrontends}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Your license for Duende BFF Security Framework has expired on {ExpirationDate}. \r\nPlease contact {licenseContact} from {licenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/expired for more information.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LicenseHasExpired(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, global::System.DateTimeOffset? expirationDate, string licenseContact, string licenseCompany)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(4);
            state.TagArray[3] = new("ExpirationDate", expirationDate);
            state.TagArray[2] = new("licenseContact", licenseContact);
            state.TagArray[1] = new("licenseCompany", licenseCompany);
            state.TagArray[0] = new("{OriginalFormat}", "Your license for Duende BFF Security Framework has expired on {ExpirationDate}. \r\nPlease contact {licenseContact} from {licenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/expired for more information.");

            logger.Log(
                level,
                new(1620871452, nameof(LicenseHasExpired)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var expirationDate = s.TagArray[3].Value ?? "(null)";
                    var licenseContact = s.TagArray[2].Value ?? "(null)";
                    var licenseCompany = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Your license for Duende BFF Security Framework has expired on {expirationDate}. \r\nPlease contact {licenseContact} from {licenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/expired for more information.");
                    #else
                    return global::System.FormattableString.Invariant($"Your license for Duende BFF Security Framework has expired on {expirationDate}. \r\nPlease contact {licenseContact} from {licenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/expired for more information.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "You do not have a valid license key for the Duende BFF Security Framework.\r\nWhen unlicensed, BFF will run in trial mode. It will limit the number of active sessions to 5.\r\nIf you are running in production you are required to have a licensed version.\r\nPlease start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/trial for more information.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NoValidLicense(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "You do not have a valid license key for the Duende BFF Security Framework.\r\nWhen unlicensed, BFF will run in trial mode. It will limit the number of active sessions to 5.\r\nIf you are running in production you are required to have a licensed version.\r\nPlease start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/trial for more information.");

            logger.Log(
                logLevel,
                new(2083751822, nameof(NoValidLicense)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "You do not have a valid license key for the Duende BFF Security Framework.\r\nWhen unlicensed, BFF will run in trial mode. It will limit the number of active sessions to 5.\r\nIf you are running in production you are required to have a licensed version.\r\nPlease start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/trial for more information.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Your license key does not include the BFF feature.\r\nBFF will run in trial mode. It will limit the number of active sessions to 5. \r\nPlease contact {LicenseContact} from {LicenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/trial for more information.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NotLicensedForBff(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string licenseContact, string licenseCompany)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("LicenseContact", licenseContact);
            state.TagArray[1] = new("LicenseCompany", licenseCompany);
            state.TagArray[0] = new("{OriginalFormat}", "Your license key does not include the BFF feature.\r\nBFF will run in trial mode. It will limit the number of active sessions to 5. \r\nPlease contact {LicenseContact} from {LicenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/trial for more information.");

            logger.Log(
                logLevel,
                new(616438795, nameof(NotLicensedForBff)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var licenseContact = s.TagArray[2].Value ?? "(null)";
                    var licenseCompany = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Your license key does not include the BFF feature.\r\nBFF will run in trial mode. It will limit the number of active sessions to 5. \r\nPlease contact {licenseContact} from {licenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/trial for more information.");
                    #else
                    return global::System.FormattableString.Invariant($"Your license key does not include the BFF feature.\r\nBFF will run in trial mode. It will limit the number of active sessions to 5. \r\nPlease contact {licenseContact} from {licenseCompany} to obtain a valid license for the Duende software,\r\nor start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/trial for more information.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Error validating the license key.If you are running in production you are required to have a licensed version. Please start a conversation with us: https://duende.link/l/bff/contact".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ErrorValidatingLicenseKey(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Error validating the license key.If you are running in production you are required to have a licensed version. Please start a conversation with us: https://duende.link/l/bff/contact");

            logger.Log(
                logLevel,
                new(1152327271, nameof(ErrorValidatingLicenseKey)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Error validating the license key.If you are running in production you are required to have a licensed version. Please start a conversation with us: https://duende.link/l/bff/contact";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Frontend #{FrontendsUsed} with name {FrontendName} was added. The license allows for unlimited frontends.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void UnlimitedFrontends(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string frontendName, int frontendsUsed)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("FrontendName", frontendName);
            state.TagArray[1] = new("FrontendsUsed", frontendsUsed);
            state.TagArray[0] = new("{OriginalFormat}", "Frontend #{FrontendsUsed} with name {FrontendName} was added. The license allows for unlimited frontends.");

            logger.Log(
                logLevel,
                new(602507404, nameof(UnlimitedFrontends)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontendName = s.TagArray[2].Value ?? "(null)";
                    var frontendsUsed = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Frontend #{frontendsUsed} with name {frontendName} was added. The license allows for unlimited frontends.");
                    #else
                    return global::System.FormattableString.Invariant($"Frontend #{frontendsUsed} with name {frontendName} was added. The license allows for unlimited frontends.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Frontend {FrontendName} was added. Currently using {frontendsUsed} of {frontendLimit} in the BFF License.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FrontendAdded(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string frontendName, int frontendsUsed, int frontendLimit)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(4);
            state.TagArray[3] = new("FrontendName", frontendName);
            state.TagArray[2] = new("frontendsUsed", frontendsUsed);
            state.TagArray[1] = new("frontendLimit", frontendLimit);
            state.TagArray[0] = new("{OriginalFormat}", "Frontend {FrontendName} was added. Currently using {frontendsUsed} of {frontendLimit} in the BFF License.");

            logger.Log(
                logLevel,
                new(429719596, nameof(FrontendAdded)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontendName = s.TagArray[3].Value ?? "(null)";
                    var frontendsUsed = s.TagArray[2].Value;
                    var frontendLimit = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Frontend {frontendName} was added. Currently using {frontendsUsed} of {frontendLimit} in the BFF License.");
                    #else
                    return global::System.FormattableString.Invariant($"Frontend {frontendName} was added. Currently using {frontendsUsed} of {frontendLimit} in the BFF License.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Frontend {FrontendName} was added. This exceeds the maximum number of frontends allowed by your license.\r\nCurrently using {frontendsUsed} of {frontendLimit} in the BFF License.\r\n\r\nSee https://duende.link/l/bff/threshold for more information.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FrontendLimitExceeded(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string frontendName, int frontendsUsed, int frontendLimit)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(4);
            state.TagArray[3] = new("FrontendName", frontendName);
            state.TagArray[2] = new("frontendsUsed", frontendsUsed);
            state.TagArray[1] = new("frontendLimit", frontendLimit);
            state.TagArray[0] = new("{OriginalFormat}", "Frontend {FrontendName} was added. This exceeds the maximum number of frontends allowed by your license.\r\nCurrently using {frontendsUsed} of {frontendLimit} in the BFF License.\r\n\r\nSee https://duende.link/l/bff/threshold for more information.");

            logger.Log(
                logLevel,
                new(1163398776, nameof(FrontendLimitExceeded)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontendName = s.TagArray[3].Value ?? "(null)";
                    var frontendsUsed = s.TagArray[2].Value;
                    var frontendLimit = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Frontend {frontendName} was added. This exceeds the maximum number of frontends allowed by your license.\r\nCurrently using {frontendsUsed} of {frontendLimit} in the BFF License.\r\n\r\nSee https://duende.link/l/bff/threshold for more information.");
                    #else
                    return global::System.FormattableString.Invariant($"Frontend {frontendName} was added. This exceeds the maximum number of frontends allowed by your license.\r\nCurrently using {frontendsUsed} of {frontendLimit} in the BFF License.\r\n\r\nSee https://duende.link/l/bff/threshold for more information.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Frontend {FrontendName} was added. However, your current license does not support multiple frontends.\r\nIf you are running in production you are required to have a license for each frontend.\r\nPlease start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/threshold for more information.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NotLicensedForMultiFrontend(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string frontendName)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("FrontendName", frontendName);
            state.TagArray[0] = new("{OriginalFormat}", "Frontend {FrontendName} was added. However, your current license does not support multiple frontends.\r\nIf you are running in production you are required to have a license for each frontend.\r\nPlease start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/threshold for more information.");

            logger.Log(
                logLevel,
                new(483064138, nameof(NotLicensedForMultiFrontend)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontendName = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Frontend {frontendName} was added. However, your current license does not support multiple frontends.\r\nIf you are running in production you are required to have a license for each frontend.\r\nPlease start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/threshold for more information.");
                    #else
                    return global::System.FormattableString.Invariant($"Frontend {frontendName} was added. However, your current license does not support multiple frontends.\r\nIf you are running in production you are required to have a license for each frontend.\r\nPlease start a conversation with us: https://duende.link/l/bff/contact\r\n\r\nSee https://duende.link/l/bff/threshold for more information.");
                    #endif
                });

            state.Clear();
        }
    }
}

namespace Duende.Bff.Otel
{
    internal static class LogMessages
    {
        /// <summary>
        /// Logs "Management URL request {Path} blocked with 404 response, because the implicit frontend is disabled.\r\n\r\nWhen you add multiple frontends, the implicit frontend is disabled. If you wish to create an implicit frontend,\r\nAdd one without Host or Path mapping.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ImplicitFrontendDisabled(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, global::Microsoft.AspNetCore.Http.PathString path)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Path", path.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Management URL request {Path} blocked with 404 response, because the implicit frontend is disabled.\r\n\r\nWhen you add multiple frontends, the implicit frontend is disabled. If you wish to create an implicit frontend,\r\nAdd one without Host or Path mapping.");

            logger.Log(
                level,
                new(469382589, nameof(ImplicitFrontendDisabled)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var path = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Management URL request {path} blocked with 404 response, because the implicit frontend is disabled.\r\n\r\nWhen you add multiple frontends, the implicit frontend is disabled. If you wish to create an implicit frontend,\r\nAdd one without Host or Path mapping.");
                    #else
                    return global::System.FormattableString.Invariant($"Management URL request {path} blocked with 404 response, because the implicit frontend is disabled.\r\n\r\nWhen you add multiple frontends, the implicit frontend is disabled. If you wish to create an implicit frontend,\r\nAdd one without Host or Path mapping.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Retrieved IndexHTML for {Frontend}. Statuscode was {StatusCode}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RetrievedIndexHTML(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend, global::System.Net.HttpStatusCode statusCode)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Frontend", frontend.ToString());
            state.TagArray[1] = new("StatusCode", statusCode);
            state.TagArray[0] = new("{OriginalFormat}", "Retrieved IndexHTML for {Frontend}. Statuscode was {StatusCode}");

            logger.Log(
                level,
                new(127338875, nameof(RetrievedIndexHTML)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[2].Value;
                    var statusCode = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Retrieved IndexHTML for {frontend}. Statuscode was {statusCode}");
                    #else
                    return global::System.FormattableString.Invariant($"Retrieved IndexHTML for {frontend}. Statuscode was {statusCode}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to retrieve IndexHTML for {Frontend}. Statuscode was {StatusCode}. This result will not be cached.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void IndexHtmlRetrievalFailed(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend, global::System.Net.HttpStatusCode statusCode)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Frontend", frontend.ToString());
            state.TagArray[1] = new("StatusCode", statusCode);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to retrieve IndexHTML for {Frontend}. Statuscode was {StatusCode}. This result will not be cached.");

            logger.Log(
                level,
                new(971421598, nameof(IndexHtmlRetrievalFailed)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[2].Value;
                    var statusCode = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to retrieve IndexHTML for {frontend}. Statuscode was {statusCode}. This result will not be cached.");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to retrieve IndexHTML for {frontend}. Statuscode was {statusCode}. This result will not be cached.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Duplicate 'default' frontend configured. This is a frontend without an origin and path. The first one is used. ".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void DuplicateDefaultRouteConfigured(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Duplicate 'default' frontend configured. This is a frontend without an origin and path. The first one is used. ");

            logger.Log(
                level,
                new(1759121909, nameof(DuplicateDefaultRouteConfigured)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Duplicate 'default' frontend configured. This is a frontend without an origin and path. The first one is used. ";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Duplicate Frontend matching criteria registered. Frontend '{Frontend}' will be ignored because it collides with frontend '{duplicate}'.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FrontendWithSimilarMatchingCriteriaAlreadyRegistered(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend, global::Duende.Bff.DynamicFrontends.BffFrontendName duplicate)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Frontend", frontend.ToString());
            state.TagArray[1] = new("duplicate", duplicate.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Duplicate Frontend matching criteria registered. Frontend '{Frontend}' will be ignored because it collides with frontend '{duplicate}'.");

            logger.Log(
                level,
                new(875495101, nameof(FrontendWithSimilarMatchingCriteriaAlreadyRegistered)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[2].Value;
                    var duplicate = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Duplicate Frontend matching criteria registered. Frontend '{frontend}' will be ignored because it collides with frontend '{duplicate}'.");
                    #else
                    return global::System.FormattableString.Invariant($"Duplicate Frontend matching criteria registered. Frontend '{frontend}' will be ignored because it collides with frontend '{duplicate}'.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to apply yarp access token request transform.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToApplyYarpAccessTokenRequestTransform(this global::Microsoft.Extensions.Logging.ILogger logger, global::System.Exception ex, global::Microsoft.Extensions.Logging.LogLevel level)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to apply yarp access token request transform.");

            logger.Log(
                level,
                new(507886080, nameof(FailedToApplyYarpAccessTokenRequestTransform)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Failed to apply yarp access token request transform.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "AllowedSilentLoginReferrers have been configured but no referer header was found on silent login callback. Returning bad request. ".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SilentLoginEndpointRefererHeaderMissing(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "AllowedSilentLoginReferrers have been configured but no referer header was found on silent login callback. Returning bad request. ");

            logger.Log(
                level,
                new(1038547159, nameof(SilentLoginEndpointRefererHeaderMissing)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "AllowedSilentLoginReferrers have been configured but no referer header was found on silent login callback. Returning bad request. ";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Referer {Referer} not in allowed referers: {AllowedReferers}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SilentLoginEndpointRefererNotAllowed(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, string referer, string allowedReferers)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Referer", referer);
            state.TagArray[1] = new("AllowedReferers", allowedReferers);
            state.TagArray[0] = new("{OriginalFormat}", "Referer {Referer} not in allowed referers: {AllowedReferers}");

            logger.Log(
                level,
                new(91029881, nameof(SilentLoginEndpointRefererNotAllowed)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var referer = s.TagArray[2].Value ?? "(null)";
                    var allowedReferers = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Referer {referer} not in allowed referers: {allowedReferers}");
                    #else
                    return global::System.FormattableString.Invariant($"Referer {referer} not in allowed referers: {allowedReferers}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Proxy response error. Path: '{Path}', error: '{Error}'".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ProxyResponseError(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel level, string path, string error)
        {
            if (!logger.IsEnabled(level))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Path", path);
            state.TagArray[1] = new("Error", error);
            state.TagArray[0] = new("{OriginalFormat}", "Proxy response error. Path: '{Path}', error: '{Error}'");

            logger.Log(
                level,
                new(387163085, nameof(ProxyResponseError)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var path = s.TagArray[2].Value ?? "(null)";
                    var error = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Proxy response error. Path: '{path}', error: '{error}'");
                    #else
                    return global::System.FormattableString.Invariant($"Proxy response error. Path: '{path}', error: '{error}'");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Deserializing AuthenticationTicket envelope failed or found incorrect version for key {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        internal static void AuthenticationTicketEnvelopeVersionInvalid(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.SessionManagement.SessionStore.UserSessionKey key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Deserializing AuthenticationTicket envelope failed or found incorrect version for key {Key}");

            logger.Log(
                logLevel,
                new(354836767, nameof(AuthenticationTicketEnvelopeVersionInvalid)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Deserializing AuthenticationTicket envelope failed or found incorrect version for key {key}");
                    #else
                    return global::System.FormattableString.Invariant($"Deserializing AuthenticationTicket envelope failed or found incorrect version for key {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to unprotect AuthenticationTicket payload for key {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void AuthenticationTicketPayloadInvalid(this global::Microsoft.Extensions.Logging.ILogger logger, global::System.Exception? ex, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.SessionManagement.SessionStore.UserSessionKey key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Failed to unprotect AuthenticationTicket payload for key {Key}");

            logger.Log(
                logLevel,
                new(863664585, nameof(AuthenticationTicketPayloadInvalid)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to unprotect AuthenticationTicket payload for key {key}");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to unprotect AuthenticationTicket payload for key {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to deserialize AuthenticationTicket payload for key {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void AuthenticationTicketFailedToDeserialize(this global::Microsoft.Extensions.Logging.ILogger logger, global::System.Exception? ex, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.SessionManagement.SessionStore.UserSessionKey key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Failed to deserialize AuthenticationTicket payload for key {Key}");

            logger.Log(
                logLevel,
                new(245709081, nameof(AuthenticationTicketFailedToDeserialize)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to deserialize AuthenticationTicket payload for key {key}");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to deserialize AuthenticationTicket payload for key {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "FrontendSelection: No frontends registered in the store.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NoFrontendsRegistered(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "FrontendSelection: No frontends registered in the store.");

            logger.Log(
                logLevel,
                new(1060368318, nameof(NoFrontendsRegistered)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "FrontendSelection: No frontends registered in the store.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Invalid prompt value {Prompt}.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void InvalidPromptValue(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string prompt)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Prompt", prompt);
            state.TagArray[0] = new("{OriginalFormat}", "Invalid prompt value {Prompt}.");

            logger.Log(
                logLevel,
                new(1772992930, nameof(InvalidPromptValue)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var prompt = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Invalid prompt value {prompt}.");
                    #else
                    return global::System.FormattableString.Invariant($"Invalid prompt value {prompt}.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Invalid return url {Url}.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void InvalidReturnUrl(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string url)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Url", url);
            state.TagArray[0] = new("{OriginalFormat}", "Invalid return url {Url}.");

            logger.Log(
                logLevel,
                new(1864635278, nameof(InvalidReturnUrl)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var url = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Invalid return url {url}.");
                    #else
                    return global::System.FormattableString.Invariant($"Invalid return url {url}.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Invalid sid {Sid}.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void InvalidSid(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Invalid sid {Sid}.");

            logger.Log(
                logLevel,
                new(1519240679, nameof(InvalidSid)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Invalid sid {sid}.");
                    #else
                    return global::System.FormattableString.Invariant($"Invalid sid {sid}.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed To clear IndexHtmlCache for BFF Frontend {Frontend}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToClearIndexHtmlCacheForFrontend(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Frontend", frontend.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Failed To clear IndexHtmlCache for BFF Frontend {Frontend}");

            logger.Log(
                logLevel,
                new(711926561, nameof(FailedToClearIndexHtmlCacheForFrontend)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed To clear IndexHtmlCache for BFF Frontend {frontend}");
                    #else
                    return global::System.FormattableString.Invariant($"Failed To clear IndexHtmlCache for BFF Frontend {frontend}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "No OpenID Configuration found for scheme {Scheme}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NoOpenIdConfigurationFoundForScheme(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.AccessTokenManagement.Scheme scheme)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Scheme", scheme.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "No OpenID Configuration found for scheme {Scheme}");

            logger.Log(
                logLevel,
                new(422555722, nameof(NoOpenIdConfigurationFoundForScheme)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var scheme = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"No OpenID Configuration found for scheme {scheme}");
                    #else
                    return global::System.FormattableString.Invariant($"No OpenID Configuration found for scheme {scheme}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "No frontend selected: None of the configured frontends matched the matching criteria.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NoFrontendSelected(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "No frontend selected: None of the configured frontends matched the matching criteria.");

            logger.Log(
                logLevel,
                new(1087834562, nameof(NoFrontendSelected)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "No frontend selected: None of the configured frontends matched the matching criteria.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "BFF is not configured to work with multiple frontends. No frontend is currently selected. ".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void MultiFrontendDisabled(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "BFF is not configured to work with multiple frontends. No frontend is currently selected. ");

            logger.Log(
                logLevel,
                new(1555283577, nameof(MultiFrontendDisabled)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "BFF is not configured to work with multiple frontends. No frontend is currently selected. ";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Selected frontend '{Frontend}'".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SelectedFrontend(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Frontend", frontend.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Selected frontend '{Frontend}'");

            logger.Log(
                logLevel,
                new(1602197389, nameof(SelectedFrontend)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Selected frontend '{frontend}'");
                    #else
                    return global::System.FormattableString.Invariant($"Selected frontend '{frontend}'");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Anti-forgery validation failed. Path: '{Path}'".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void AntiForgeryValidationFailed(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string path)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Path", path);
            state.TagArray[0] = new("{OriginalFormat}", "Anti-forgery validation failed. Path: '{Path}'");

            logger.Log(
                logLevel,
                new(146559854, nameof(AntiForgeryValidationFailed)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var path = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Anti-forgery validation failed. Path: '{path}'");
                    #else
                    return global::System.FormattableString.Invariant($"Anti-forgery validation failed. Path: '{path}'");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Back-channel logout. sub: '{Sub}', sid: '{Sid}'".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void BackChannelLogout(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string sub, string sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Back-channel logout. sub: '{Sub}', sid: '{Sid}'");

            logger.Log(
                logLevel,
                new(920465342, nameof(BackChannelLogout)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Back-channel logout. sub: '{sub}', sid: '{sid}'");
                    #else
                    return global::System.FormattableString.Invariant($"Back-channel logout. sub: '{sub}', sid: '{sid}'");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Access token is missing. token type: '{TokenType}', Path: '{Path}', detail: '{Detail}'".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void AccessTokenMissing(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string tokenType, string path, string detail)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(4);
            state.TagArray[3] = new("TokenType", tokenType);
            state.TagArray[2] = new("Path", path);
            state.TagArray[1] = new("Detail", detail);
            state.TagArray[0] = new("{OriginalFormat}", "Access token is missing. token type: '{TokenType}', Path: '{Path}', detail: '{Detail}'");

            logger.Log(
                logLevel,
                new(687218971, nameof(AccessTokenMissing)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var tokenType = s.TagArray[3].Value ?? "(null)";
                    var path = s.TagArray[2].Value ?? "(null)";
                    var detail = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Access token is missing. token type: '{tokenType}', Path: '{path}', detail: '{detail}'");
                    #else
                    return global::System.FormattableString.Invariant($"Access token is missing. token type: '{tokenType}', Path: '{path}', detail: '{detail}'");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Invalid route configuration. Cannot combine a required access token (a call to WithAccessToken) and an optional access token (a call to WithOptionalUserAccessToken). clusterId: '{ClusterId}', routeId: '{RouteId}'".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void InvalidRouteConfiguration(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? clusterId, string routeId)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("ClusterId", clusterId);
            state.TagArray[1] = new("RouteId", routeId);
            state.TagArray[0] = new("{OriginalFormat}", "Invalid route configuration. Cannot combine a required access token (a call to WithAccessToken) and an optional access token (a call to WithOptionalUserAccessToken). clusterId: '{ClusterId}', routeId: '{RouteId}'");

            logger.Log(
                logLevel,
                new(1891888800, nameof(InvalidRouteConfiguration)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var clusterId = s.TagArray[2].Value ?? "(null)";
                    var routeId = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Invalid route configuration. Cannot combine a required access token (a call to WithAccessToken) and an optional access token (a call to WithOptionalUserAccessToken). clusterId: '{clusterId}', routeId: '{routeId}'");
                    #else
                    return global::System.FormattableString.Invariant($"Invalid route configuration. Cannot combine a required access token (a call to WithAccessToken) and an optional access token (a call to WithOptionalUserAccessToken). clusterId: '{clusterId}', routeId: '{routeId}'");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to request new User Access Token due to: {Error}. This can mean that the refresh token is expired or revoked but the cookie session is still active. If the session was not revoked, ensure that the session cookie lifetime is smaller than the refresh token lifetime.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToRequestNewUserAccessToken(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string error)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Error", error);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to request new User Access Token due to: {Error}. This can mean that the refresh token is expired or revoked but the cookie session is still active. If the session was not revoked, ensure that the session cookie lifetime is smaller than the refresh token lifetime.");

            logger.Log(
                logLevel,
                new(39149415, nameof(FailedToRequestNewUserAccessToken)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var error = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to request new User Access Token due to: {error}. This can mean that the refresh token is expired or revoked but the cookie session is still active. If the session was not revoked, ensure that the session cookie lifetime is smaller than the refresh token lifetime.");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to request new User Access Token due to: {error}. This can mean that the refresh token is expired or revoked but the cookie session is still active. If the session was not revoked, ensure that the session cookie lifetime is smaller than the refresh token lifetime.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to request new User Access Token due to: {Error}. This likely means that the user's refresh token is expired or revoked. The user's session will be ended, which will force the user to log in.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void UserSessionRevoked(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string error)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Error", error);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to request new User Access Token due to: {Error}. This likely means that the user's refresh token is expired or revoked. The user's session will be ended, which will force the user to log in.");

            logger.Log(
                logLevel,
                new(804513411, nameof(UserSessionRevoked)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var error = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to request new User Access Token due to: {error}. This likely means that the user's refresh token is expired or revoked. The user's session will be ended, which will force the user to log in.");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to request new User Access Token due to: {error}. This likely means that the user's refresh token is expired or revoked. The user's session will be ended, which will force the user to log in.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "BFF management endpoint {endpoint} is only intended for a browser window to request and load. It is not intended to be accessed with Ajax or fetch requests.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ManagementEndpointAccessedViaAjax(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string endpoint)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("endpoint", endpoint);
            state.TagArray[0] = new("{OriginalFormat}", "BFF management endpoint {endpoint} is only intended for a browser window to request and load. It is not intended to be accessed with Ajax or fetch requests.");

            logger.Log(
                logLevel,
                new(441059535, nameof(ManagementEndpointAccessedViaAjax)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var endpoint = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"BFF management endpoint {endpoint} is only intended for a browser window to request and load. It is not intended to be accessed with Ajax or fetch requests.");
                    #else
                    return global::System.FormattableString.Invariant($"BFF management endpoint {endpoint} is only intended for a browser window to request and load. It is not intended to be accessed with Ajax or fetch requests.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Challenge was called for a BFF API endpoint, BFF response handling changing status code to 401.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ChallengeForBffApiEndpoint(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Challenge was called for a BFF API endpoint, BFF response handling changing status code to 401.");

            logger.Log(
                logLevel,
                new(642681511, nameof(ChallengeForBffApiEndpoint)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Challenge was called for a BFF API endpoint, BFF response handling changing status code to 401.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Forbid was called for a BFF API endpoint, BFF response handling changing status code to 403.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ForbidForBffApiEndpoint(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Forbid was called for a BFF API endpoint, BFF response handling changing status code to 403.");

            logger.Log(
                logLevel,
                new(655421072, nameof(ForbidForBffApiEndpoint)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Forbid was called for a BFF API endpoint, BFF response handling changing status code to 403.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Creating user session record in store for sub {Sub} sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void CreatingUserSession(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Creating user session record in store for sub {Sub} sid {Sid}");

            logger.Log(
                logLevel,
                new(1874888402, nameof(CreatingUserSession)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Creating user session record in store for sub {sub} sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Creating user session record in store for sub {sub} sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Detected a duplicate insert of the same session. This can happen when multiple browser tabs are open and can safely be ignored.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void DuplicateSessionInsertDetected(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception? ex = null)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Detected a duplicate insert of the same session. This can happen when multiple browser tabs are open and can safely be ignored.");

            logger.Log(
                logLevel,
                new(83103844, nameof(DuplicateSessionInsertDetected)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Detected a duplicate insert of the same session. This can happen when multiple browser tabs are open and can safely be ignored.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Exception creating new server-side session in database: {Error}. If this is a duplicate key error, it's safe to ignore. This can happen (for example) when two identical tabs are open.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ExceptionCreatingSession(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex, string error)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Error", error);
            state.TagArray[0] = new("{OriginalFormat}", "Exception creating new server-side session in database: {Error}. If this is a duplicate key error, it's safe to ignore. This can happen (for example) when two identical tabs are open.");

            logger.Log(
                logLevel,
                new(54160514, nameof(ExceptionCreatingSession)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var error = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Exception creating new server-side session in database: {error}. If this is a duplicate key error, it's safe to ignore. This can happen (for example) when two identical tabs are open.");
                    #else
                    return global::System.FormattableString.Invariant($"Exception creating new server-side session in database: {error}. If this is a duplicate key error, it's safe to ignore. This can happen (for example) when two identical tabs are open.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "No record found in user session store when trying to delete user session for key {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NoRecordFoundForKey(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.SessionManagement.SessionStore.UserSessionKey key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "No record found in user session store when trying to delete user session for key {Key}");

            logger.Log(
                logLevel,
                new(1160496550, nameof(NoRecordFoundForKey)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"No record found in user session store when trying to delete user session for key {key}");
                    #else
                    return global::System.FormattableString.Invariant($"No record found in user session store when trying to delete user session for key {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Deleting user session record in store for sub {Sub} sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void DeletingUserSession(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Deleting user session record in store for sub {Sub} sid {Sid}");

            logger.Log(
                logLevel,
                new(959361069, nameof(DeletingUserSession)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Deleting user session record in store for sub {sub} sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Deleting user session record in store for sub {sub} sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "DbUpdateConcurrencyException: {Error}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void DbUpdateConcurrencyException(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string error)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Error", error);
            state.TagArray[0] = new("{OriginalFormat}", "DbUpdateConcurrencyException: {Error}");

            logger.Log(
                logLevel,
                new(1569080331, nameof(DbUpdateConcurrencyException)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var error = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"DbUpdateConcurrencyException: {error}");
                    #else
                    return global::System.FormattableString.Invariant($"DbUpdateConcurrencyException: {error}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Getting user session record from store for sub {Sub} sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void GettingUserSession(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Getting user session record from store for sub {Sub} sid {Sid}");

            logger.Log(
                logLevel,
                new(1913398477, nameof(GettingUserSession)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Getting user session record from store for sub {sub} sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Getting user session record from store for sub {sub} sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Getting {Count} user session(s) from store for sub {Sub} sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void GettingUserSessions(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, int count, string? sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(4);
            state.TagArray[3] = new("Count", count);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Getting {Count} user session(s) from store for sub {Sub} sid {Sid}");

            logger.Log(
                logLevel,
                new(326910376, nameof(GettingUserSessions)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var count = s.TagArray[3].Value;
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Getting {count} user session(s) from store for sub {sub} sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Getting {count} user session(s) from store for sub {sub} sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Deleting {Count} user session(s) from store for sub {Sub} sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void DeletingUserSessions(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, int count, string? sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(4);
            state.TagArray[3] = new("Count", count);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Deleting {Count} user session(s) from store for sub {Sub} sid {Sid}");

            logger.Log(
                logLevel,
                new(1394785822, nameof(DeletingUserSessions)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var count = s.TagArray[3].Value;
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Deleting {count} user session(s) from store for sub {sub} sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Deleting {count} user session(s) from store for sub {sub} sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Updating user session record in store for sub {Sub} sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void UpdatingUserSession(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Updating user session record in store for sub {Sub} sid {Sid}");

            logger.Log(
                logLevel,
                new(40359619, nameof(UpdatingUserSession)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Updating user session record in store for sub {sub} sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Updating user session record in store for sub {sub} sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Removing {Count} server side sessions".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RemovingServerSideSessions(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, int count)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Count", count);
            state.TagArray[0] = new("{OriginalFormat}", "Removing {Count} server side sessions");

            logger.Log(
                logLevel,
                new(1803003422, nameof(RemovingServerSideSessions)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var count = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Removing {count} server side sessions");
                    #else
                    return global::System.FormattableString.Invariant($"Removing {count} server side sessions");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Retrieving token for user {User}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RetrievingTokenForUser(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? user)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("User", user);
            state.TagArray[0] = new("{OriginalFormat}", "Retrieving token for user {User}");

            logger.Log(
                logLevel,
                new(817366252, nameof(RetrievingTokenForUser)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var user = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Retrieving token for user {user}");
                    #else
                    return global::System.FormattableString.Invariant($"Retrieving token for user {user}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Retrieving session {Sid} for sub {Sub}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RetrievingSession(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string sid, string sub)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sid", sid);
            state.TagArray[1] = new("Sub", sub);
            state.TagArray[0] = new("{OriginalFormat}", "Retrieving session {Sid} for sub {Sub}");

            logger.Log(
                logLevel,
                new(2015766163, nameof(RetrievingSession)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sid = s.TagArray[2].Value ?? "(null)";
                    var sub = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Retrieving session {sid} for sub {sub}");
                    #else
                    return global::System.FormattableString.Invariant($"Retrieving session {sid} for sub {sub}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Storing token for user {User}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void StoringTokenForUser(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? user)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("User", user);
            state.TagArray[0] = new("{OriginalFormat}", "Storing token for user {User}");

            logger.Log(
                logLevel,
                new(1675488649, nameof(StoringTokenForUser)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var user = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Storing token for user {user}");
                    #else
                    return global::System.FormattableString.Invariant($"Storing token for user {user}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Removing token for user {User}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RemovingTokenForUser(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? user)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("User", user);
            state.TagArray[0] = new("{OriginalFormat}", "Removing token for user {User}");

            logger.Log(
                logLevel,
                new(1247903432, nameof(RemovingTokenForUser)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var user = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Removing token for user {user}");
                    #else
                    return global::System.FormattableString.Invariant($"Removing token for user {user}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to find a session to update, bailing out".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToFindSessionToUpdate(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to find a session to update, bailing out");

            logger.Log(
                logLevel,
                new(1686152447, nameof(FailedToFindSessionToUpdate)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Failed to find a session to update, bailing out";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Creating entry in store for AuthenticationTicket, key {Key}, with expiration: {Expiration}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void CreatingAuthenticationTicketEntry(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string key, global::System.DateTime? expiration)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Key", key);
            state.TagArray[1] = new("Expiration", expiration);
            state.TagArray[0] = new("{OriginalFormat}", "Creating entry in store for AuthenticationTicket, key {Key}, with expiration: {Expiration}");

            logger.Log(
                logLevel,
                new(960199371, nameof(CreatingAuthenticationTicketEntry)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[2].Value ?? "(null)";
                    var expiration = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Creating entry in store for AuthenticationTicket, key {key}, with expiration: {expiration}");
                    #else
                    return global::System.FormattableString.Invariant($"Creating entry in store for AuthenticationTicket, key {key}, with expiration: {expiration}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Retrieve AuthenticationTicket for key {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RetrieveAuthenticationTicket(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key);
            state.TagArray[0] = new("{OriginalFormat}", "Retrieve AuthenticationTicket for key {Key}");

            logger.Log(
                logLevel,
                new(65815620, nameof(RetrieveAuthenticationTicket)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Retrieve AuthenticationTicket for key {key}");
                    #else
                    return global::System.FormattableString.Invariant($"Retrieve AuthenticationTicket for key {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Ticket loaded for key: {Key}, with expiration: {Expiration}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void TicketLoaded(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string key, global::System.DateTime? expiration)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Key", key);
            state.TagArray[1] = new("Expiration", expiration);
            state.TagArray[0] = new("{OriginalFormat}", "Ticket loaded for key: {Key}, with expiration: {Expiration}");

            logger.Log(
                logLevel,
                new(1224988019, nameof(TicketLoaded)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[2].Value ?? "(null)";
                    var expiration = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Ticket loaded for key: {key}, with expiration: {expiration}");
                    #else
                    return global::System.FormattableString.Invariant($"Ticket loaded for key: {key}, with expiration: {expiration}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "No AuthenticationTicket found in store for {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NoAuthenticationTicketFoundForKey(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key);
            state.TagArray[0] = new("{OriginalFormat}", "No AuthenticationTicket found in store for {Key}");

            logger.Log(
                logLevel,
                new(426988975, nameof(NoAuthenticationTicketFoundForKey)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"No AuthenticationTicket found in store for {key}");
                    #else
                    return global::System.FormattableString.Invariant($"No AuthenticationTicket found in store for {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to deserialize authentication ticket from store, deleting record for key {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToDeserializeAuthenticationTicket(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to deserialize authentication ticket from store, deleting record for key {Key}");

            logger.Log(
                logLevel,
                new(1300162747, nameof(FailedToDeserializeAuthenticationTicket)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to deserialize authentication ticket from store, deleting record for key {key}");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to deserialize authentication ticket from store, deleting record for key {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Renewing AuthenticationTicket for key {Key}, with expiration: {Expiration}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RenewingAuthenticationTicket(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string key, global::System.DateTime? expiration)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Key", key);
            state.TagArray[1] = new("Expiration", expiration);
            state.TagArray[0] = new("{OriginalFormat}", "Renewing AuthenticationTicket for key {Key}, with expiration: {Expiration}");

            logger.Log(
                logLevel,
                new(707874553, nameof(RenewingAuthenticationTicket)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[2].Value ?? "(null)";
                    var expiration = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Renewing AuthenticationTicket for key {key}, with expiration: {expiration}");
                    #else
                    return global::System.FormattableString.Invariant($"Renewing AuthenticationTicket for key {key}, with expiration: {expiration}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Removing AuthenticationTicket from store for key {Key}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RemovingAuthenticationTicket(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string key)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Key", key);
            state.TagArray[0] = new("{OriginalFormat}", "Removing AuthenticationTicket from store for key {Key}");

            logger.Log(
                logLevel,
                new(1961829635, nameof(RemovingAuthenticationTicket)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var key = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Removing AuthenticationTicket from store for key {key}");
                    #else
                    return global::System.FormattableString.Invariant($"Removing AuthenticationTicket from store for key {key}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Getting AuthenticationTickets from store for sub {Sub} sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void GettingAuthenticationTickets(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Getting AuthenticationTickets from store for sub {Sub} sid {Sid}");

            logger.Log(
                logLevel,
                new(622682141, nameof(GettingAuthenticationTickets)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Getting AuthenticationTickets from store for sub {sub} sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Getting AuthenticationTickets from store for sub {sub} sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Frontend selected via path mapping '{PathMapping}', but request path '{Path}' has different case. Cookie path names are case sensitive, so the cookie likely doesn't work.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FrontendSelectedWithPathCasingIssue(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string pathMapping, global::Microsoft.AspNetCore.Http.PathString path)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("PathMapping", pathMapping);
            state.TagArray[1] = new("Path", path.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Frontend selected via path mapping '{PathMapping}', but request path '{Path}' has different case. Cookie path names are case sensitive, so the cookie likely doesn't work.");

            logger.Log(
                logLevel,
                new(1880243510, nameof(FrontendSelectedWithPathCasingIssue)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var pathMapping = s.TagArray[2].Value ?? "(null)";
                    var path = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Frontend selected via path mapping '{pathMapping}', but request path '{path}' has different case. Cookie path names are case sensitive, so the cookie likely doesn't work.");
                    #else
                    return global::System.FormattableString.Invariant($"Frontend selected via path mapping '{pathMapping}', but request path '{path}' has different case. Cookie path names are case sensitive, so the cookie likely doesn't work.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Management endpoints are automatically mapped, so the call to MapBffManagementEndpoints will be ignored. If you're using BffOptions.AutomaticallyRegisterBffMiddleware, you don't need to call endpoints.MapBffManagementEndpoints()".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void AlreadyMappedManagementEndpoints(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Management endpoints are automatically mapped, so the call to MapBffManagementEndpoints will be ignored. If you're using BffOptions.AutomaticallyRegisterBffMiddleware, you don't need to call endpoints.MapBffManagementEndpoints()");

            logger.Log(
                logLevel,
                new(1219957122, nameof(AlreadyMappedManagementEndpoints)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Management endpoints are automatically mapped, so the call to MapBffManagementEndpoints will be ignored. If you're using BffOptions.AutomaticallyRegisterBffMiddleware, you don't need to call endpoints.MapBffManagementEndpoints()";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Authenticating scheme: {Scheme}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void AuthenticatingScheme(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? scheme)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Scheme", scheme);
            state.TagArray[0] = new("{OriginalFormat}", "Authenticating scheme: {Scheme}");

            logger.Log(
                logLevel,
                new(1078491209, nameof(AuthenticatingScheme)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var scheme = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Authenticating scheme: {scheme}");
                    #else
                    return global::System.FormattableString.Invariant($"Authenticating scheme: {scheme}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Signing out of scheme: {Scheme}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SigningOutOfScheme(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? scheme)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Scheme", scheme);
            state.TagArray[0] = new("{OriginalFormat}", "Signing out of scheme: {Scheme}");

            logger.Log(
                logLevel,
                new(2030830787, nameof(SigningOutOfScheme)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var scheme = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Signing out of scheme: {scheme}");
                    #else
                    return global::System.FormattableString.Invariant($"Signing out of scheme: {scheme}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Setting OIDC ProtocolMessage.Prompt to 'none' for BFF silent login".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SettingOidcPromptNoneForSilentLogin(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Setting OIDC ProtocolMessage.Prompt to 'none' for BFF silent login");

            logger.Log(
                logLevel,
                new(1767730600, nameof(SettingOidcPromptNoneForSilentLogin)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Setting OIDC ProtocolMessage.Prompt to 'none' for BFF silent login";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Setting OIDC ProtocolMessage.Prompt to {Prompt} for BFF silent login".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SettingOidcPromptForSilentLogin(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string prompt)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Prompt", prompt);
            state.TagArray[0] = new("{OriginalFormat}", "Setting OIDC ProtocolMessage.Prompt to {Prompt} for BFF silent login");

            logger.Log(
                logLevel,
                new(573166490, nameof(SettingOidcPromptForSilentLogin)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var prompt = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Setting OIDC ProtocolMessage.Prompt to {prompt} for BFF silent login");
                    #else
                    return global::System.FormattableString.Invariant($"Setting OIDC ProtocolMessage.Prompt to {prompt} for BFF silent login");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Handling error response from OIDC provider for BFF silent login.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void HandlingErrorResponseFromOidcProviderForSilentLogin(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Handling error response from OIDC provider for BFF silent login.");

            logger.Log(
                logLevel,
                new(1137832901, nameof(HandlingErrorResponseFromOidcProviderForSilentLogin)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Handling error response from OIDC provider for BFF silent login.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Handling failed response from OIDC provider for BFF silent login.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void HandlingFailedResponseFromOidcProviderForSilentLogin(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Handling failed response from OIDC provider for BFF silent login.");

            logger.Log(
                logLevel,
                new(177583912, nameof(HandlingFailedResponseFromOidcProviderForSilentLogin)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Handling failed response from OIDC provider for BFF silent login.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Processing back-channel logout request".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ProcessingBackChannelLogoutRequest(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Processing back-channel logout request");

            logger.Log(
                logLevel,
                new(772319522, nameof(ProcessingBackChannelLogoutRequest)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Processing back-channel logout request";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "No claims in back-channel JWT".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NoClaimsInBackChannelJwt(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "No claims in back-channel JWT");

            logger.Log(
                logLevel,
                new(1573613638, nameof(NoClaimsInBackChannelJwt)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "No claims in back-channel JWT";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Claims found in back-channel JWT {Claims}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ClaimsFoundInBackChannelJwt(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string claims)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Claims", claims);
            state.TagArray[0] = new("{OriginalFormat}", "Claims found in back-channel JWT {Claims}");

            logger.Log(
                logLevel,
                new(1092893573, nameof(ClaimsFoundInBackChannelJwt)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var claims = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Claims found in back-channel JWT {claims}");
                    #else
                    return global::System.FormattableString.Invariant($"Claims found in back-channel JWT {claims}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Back-channel JWT validation successful".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void BackChannelJwtValidationSuccessful(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Back-channel JWT validation successful");

            logger.Log(
                logLevel,
                new(664219482, nameof(BackChannelJwtValidationSuccessful)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Back-channel JWT validation successful";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Processing login request".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ProcessingLoginRequest(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Processing login request");

            logger.Log(
                logLevel,
                new(389857127, nameof(ProcessingLoginRequest)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Processing login request";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Login endpoint triggering Challenge with returnUrl {ReturnUrl}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LoginEndpointTriggeringChallenge(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string returnUrl)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("ReturnUrl", returnUrl);
            state.TagArray[0] = new("{OriginalFormat}", "Login endpoint triggering Challenge with returnUrl {ReturnUrl}");

            logger.Log(
                logLevel,
                new(1273811029, nameof(LoginEndpointTriggeringChallenge)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var returnUrl = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Login endpoint triggering Challenge with returnUrl {returnUrl}");
                    #else
                    return global::System.FormattableString.Invariant($"Login endpoint triggering Challenge with returnUrl {returnUrl}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Processing logout request".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ProcessingLogoutRequest(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Processing logout request");

            logger.Log(
                logLevel,
                new(598692640, nameof(ProcessingLogoutRequest)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Processing logout request";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Logout endpoint triggering SignOut with returnUrl {ReturnUrl}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LogoutEndpointTriggeringSignOut(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string returnUrl)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("ReturnUrl", returnUrl);
            state.TagArray[0] = new("{OriginalFormat}", "Logout endpoint triggering SignOut with returnUrl {ReturnUrl}");

            logger.Log(
                logLevel,
                new(247223768, nameof(LogoutEndpointTriggeringSignOut)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var returnUrl = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Logout endpoint triggering SignOut with returnUrl {returnUrl}");
                    #else
                    return global::System.FormattableString.Invariant($"Logout endpoint triggering SignOut with returnUrl {returnUrl}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Processing silent login callback request".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ProcessingSilentLoginCallbackRequest(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Processing silent login callback request");

            logger.Log(
                logLevel,
                new(301260843, nameof(ProcessingSilentLoginCallbackRequest)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Processing silent login callback request";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Silent login endpoint rendering HTML with JS postMessage to origin {Origin} with isLoggedIn {IsLoggedIn}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SilentLoginEndpointRenderingHtml(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string origin, string isLoggedIn)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Origin", origin);
            state.TagArray[1] = new("IsLoggedIn", isLoggedIn);
            state.TagArray[0] = new("{OriginalFormat}", "Silent login endpoint rendering HTML with JS postMessage to origin {Origin} with isLoggedIn {IsLoggedIn}");

            logger.Log(
                logLevel,
                new(1109308436, nameof(SilentLoginEndpointRenderingHtml)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var origin = s.TagArray[2].Value ?? "(null)";
                    var isLoggedIn = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Silent login endpoint rendering HTML with JS postMessage to origin {origin} with isLoggedIn {isLoggedIn}");
                    #else
                    return global::System.FormattableString.Invariant($"Silent login endpoint rendering HTML with JS postMessage to origin {origin} with isLoggedIn {isLoggedIn}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Processing silent login request".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ProcessingSilentLoginRequest(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Processing silent login request");

            logger.Log(
                logLevel,
                new(1638734764, nameof(ProcessingSilentLoginRequest)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Processing silent login request";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Using deprecated silentlogin endpoint. This endpoint will be removed in future versions. Consider calling the BFF Login endpoint with prompt=none.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void UsingDeprecatedSilentLoginEndpoint(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Using deprecated silentlogin endpoint. This endpoint will be removed in future versions. Consider calling the BFF Login endpoint with prompt=none.");

            logger.Log(
                logLevel,
                new(123372604, nameof(UsingDeprecatedSilentLoginEndpoint)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Using deprecated silentlogin endpoint. This endpoint will be removed in future versions. Consider calling the BFF Login endpoint with prompt=none.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Processing user request".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ProcessingUserRequest(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Processing user request");

            logger.Log(
                logLevel,
                new(307967645, nameof(ProcessingUserRequest)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Processing user request";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "User endpoint indicates the user is not logged in, using status code {StatusCode}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void UserEndpointNotLoggedIn(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, int statusCode)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("StatusCode", statusCode);
            state.TagArray[0] = new("{OriginalFormat}", "User endpoint indicates the user is not logged in, using status code {StatusCode}");

            logger.Log(
                logLevel,
                new(837397288, nameof(UserEndpointNotLoggedIn)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var statusCode = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"User endpoint indicates the user is not logged in, using status code {statusCode}");
                    #else
                    return global::System.FormattableString.Invariant($"User endpoint indicates the user is not logged in, using status code {statusCode}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "User endpoint indicates the user is logged in with claims {Claims}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void UserEndpointLoggedInWithClaims(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string claims)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Claims", claims);
            state.TagArray[0] = new("{OriginalFormat}", "User endpoint indicates the user is logged in with claims {Claims}");

            logger.Log(
                logLevel,
                new(509704106, nameof(UserEndpointLoggedInWithClaims)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var claims = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"User endpoint indicates the user is logged in with claims {claims}");
                    #else
                    return global::System.FormattableString.Invariant($"User endpoint indicates the user is logged in with claims {claims}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Nop implementation of session revocation for sub: {Sub}, and sid: {Sid}. Implement ISessionRevocationService to provide your own implementation.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void NopSessionRevocation(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Nop implementation of session revocation for sub: {Sub}, and sid: {Sid}. Implement ISessionRevocationService to provide your own implementation.");

            logger.Log(
                logLevel,
                new(1523221365, nameof(NopSessionRevocation)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Nop implementation of session revocation for sub: {sub}, and sid: {sid}. Implement ISessionRevocationService to provide your own implementation.");
                    #else
                    return global::System.FormattableString.Invariant($"Nop implementation of session revocation for sub: {sub}, and sid: {sid}. Implement ISessionRevocationService to provide your own implementation.");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Revoking sessions for sub {Sub} and sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RevokingSessions(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Revoking sessions for sub {Sub} and sid {Sid}");

            logger.Log(
                logLevel,
                new(699009608, nameof(RevokingSessions)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Revoking sessions for sub {sub} and sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Revoking sessions for sub {sub} and sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Refresh token revoked for sub {Sub} and sid {Sid}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RefreshTokenRevoked(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string sub, string? sid)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(3);
            state.TagArray[2] = new("Sub", sub);
            state.TagArray[1] = new("Sid", sid);
            state.TagArray[0] = new("{OriginalFormat}", "Refresh token revoked for sub {Sub} and sid {Sid}");

            logger.Log(
                logLevel,
                new(1838828912, nameof(RefreshTokenRevoked)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[2].Value ?? "(null)";
                    var sid = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Refresh token revoked for sub {sub} and sid {sid}");
                    #else
                    return global::System.FormattableString.Invariant($"Refresh token revoked for sub {sub} and sid {sid}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "BFF session cleanup is enabled, but no IUserSessionStoreCleanup is registered in DI. BFF session cleanup will not run.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SessionCleanupNotRegistered(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "BFF session cleanup is enabled, but no IUserSessionStoreCleanup is registered in DI. BFF session cleanup will not run.");

            logger.Log(
                logLevel,
                new(1929165299, nameof(SessionCleanupNotRegistered)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "BFF session cleanup is enabled, but no IUserSessionStoreCleanup is registered in DI. BFF session cleanup will not run.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to cleanup session".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToCleanupSession(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to cleanup session");

            logger.Log(
                logLevel,
                new(1657212172, nameof(FailedToCleanupSession)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Failed to cleanup session";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to cleanup expired sessions".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToCleanupExpiredSessions(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to cleanup expired sessions");

            logger.Log(
                logLevel,
                new(818018788, nameof(FailedToCleanupExpiredSessions)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Failed to cleanup expired sessions";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Revoking user's refresh tokens in OnSigningOut for subject id: {Sub}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void RevokingUserRefreshTokensOnSigningOut(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, string? sub)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Sub", sub);
            state.TagArray[0] = new("{OriginalFormat}", "Revoking user's refresh tokens in OnSigningOut for subject id: {Sub}");

            logger.Log(
                logLevel,
                new(1414129037, nameof(RevokingUserRefreshTokensOnSigningOut)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var sub = s.TagArray[1].Value ?? "(null)";
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Revoking user's refresh tokens in OnSigningOut for subject id: {sub}");
                    #else
                    return global::System.FormattableString.Invariant($"Revoking user's refresh tokens in OnSigningOut for subject id: {sub}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Explicitly setting ShouldRenew=false in OnValidatePrincipal due to query param suppressing slide behavior.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SuppressingSlideBehaviorOnValidatePrincipal(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Explicitly setting ShouldRenew=false in OnValidatePrincipal due to query param suppressing slide behavior.");

            logger.Log(
                logLevel,
                new(1610470401, nameof(SuppressingSlideBehaviorOnValidatePrincipal)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Explicitly setting ShouldRenew=false in OnValidatePrincipal due to query param suppressing slide behavior.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Explicitly setting ShouldRenew=false in OnCheckSlidingExpiration due to query param suppressing slide behavior.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void SuppressingSlideBehaviorOnCheckSlidingExpiration(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Explicitly setting ShouldRenew=false in OnCheckSlidingExpiration due to query param suppressing slide behavior.");

            logger.Log(
                logLevel,
                new(199146006, nameof(SuppressingSlideBehaviorOnCheckSlidingExpiration)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Explicitly setting ShouldRenew=false in OnCheckSlidingExpiration due to query param suppressing slide behavior.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to process backchannel logout request. 'Logout token is missing'".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToProcessBackchannelLogoutRequestMissingToken(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to process backchannel logout request. 'Logout token is missing'");

            logger.Log(
                logLevel,
                new(1894136923, nameof(FailedToProcessBackchannelLogoutRequestMissingToken)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Failed to process backchannel logout request. 'Logout token is missing'";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to process backchannel logout request.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToProcessBackchannelLogoutRequest(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Failed to process backchannel logout request.");

            logger.Log(
                logLevel,
                new(219471514, nameof(FailedToProcessBackchannelLogoutRequest)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Failed to process backchannel logout request.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Logout token missing sub and sid claims.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LogoutTokenMissingSubAndSidClaims(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Logout token missing sub and sid claims.");

            logger.Log(
                logLevel,
                new(928131743, nameof(LogoutTokenMissingSubAndSidClaims)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Logout token missing sub and sid claims.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Logout token should not contain nonce claim.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LogoutTokenShouldNotContainNonceClaim(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Logout token should not contain nonce claim.");

            logger.Log(
                logLevel,
                new(294943236, nameof(LogoutTokenShouldNotContainNonceClaim)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Logout token should not contain nonce claim.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Logout token missing events claim.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LogoutTokenMissingEventsClaim(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Logout token missing events claim.");

            logger.Log(
                logLevel,
                new(2146508878, nameof(LogoutTokenMissingEventsClaim)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Logout token missing events claim.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Logout token contains missing http://schemas.openid.net/event/backchannel-logout value.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LogoutTokenMissingBackchannelLogoutValue(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Logout token contains missing http://schemas.openid.net/event/backchannel-logout value.");

            logger.Log(
                logLevel,
                new(1202315764, nameof(LogoutTokenMissingBackchannelLogoutValue)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Logout token contains missing http://schemas.openid.net/event/backchannel-logout value.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Logout token contains invalid JSON in events claim value.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void LogoutTokenContainsInvalidJsonInEventsClaim(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Logout token contains invalid JSON in events claim value.");

            logger.Log(
                logLevel,
                new(493575433, nameof(LogoutTokenContainsInvalidJsonInEventsClaim)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Logout token contains invalid JSON in events claim value.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Error validating logout token.".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ErrorValidatingLogoutToken(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Error validating logout token.");

            logger.Log(
                logLevel,
                new(1001889170, nameof(ErrorValidatingLogoutToken)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Error validating logout token.";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "A changed frontend was detected. Clearing caches for frontend {Frontend}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ChangedFrontendDetected_ClearingCaches(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Frontend", frontend.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "A changed frontend was detected. Clearing caches for frontend {Frontend}");

            logger.Log(
                logLevel,
                new(713030089, nameof(ChangedFrontendDetected_ClearingCaches)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"A changed frontend was detected. Clearing caches for frontend {frontend}");
                    #else
                    return global::System.FormattableString.Invariant($"A changed frontend was detected. Clearing caches for frontend {frontend}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to clear hybrid cache for frontend {Frontend}".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToClearSchemeCache(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend, global::System.Exception ex)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Frontend", frontend.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Failed to clear hybrid cache for frontend {Frontend}");

            logger.Log(
                logLevel,
                new(487089464, nameof(FailedToClearSchemeCache)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to clear hybrid cache for frontend {frontend}");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to clear hybrid cache for frontend {frontend}");
                    #endif
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Error occurred while processing frontend changes".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void ErrorWhileProcessingFrontendChanges(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::System.Exception ex)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(1);
            state.TagArray[0] = new("{OriginalFormat}", "Error occurred while processing frontend changes");

            logger.Log(
                logLevel,
                new(336053397, nameof(ErrorWhileProcessingFrontendChanges)),
                state,
                ex,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    return "Error occurred while processing frontend changes";
                });

            state.Clear();
        }

        /// <summary>
        /// Logs "Failed to add frontend change to {Frontend} to queue".
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")]
        public static void FailedToAddFrontendToQueue(this global::Microsoft.Extensions.Logging.ILogger logger, global::Microsoft.Extensions.Logging.LogLevel logLevel, global::Duende.Bff.DynamicFrontends.BffFrontendName frontend)
        {
            if (!logger.IsEnabled(logLevel))
            {
                return;
            }

            var state = global::Microsoft.Extensions.Logging.LoggerMessageHelper.ThreadLocalState;

            _ = state.ReserveTagSpace(2);
            state.TagArray[1] = new("Frontend", frontend.ToString());
            state.TagArray[0] = new("{OriginalFormat}", "Failed to add frontend change to {Frontend} to queue");

            logger.Log(
                logLevel,
                new(1846665177, nameof(FailedToAddFrontendToQueue)),
                state,
                null,
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Gen.Logging", "9.1.0.0")] static string (s, _) =>
                {
                    var frontend = s.TagArray[1].Value;
                    #if NET
                    return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"Failed to add frontend change to {frontend} to queue");
                    #else
                    return global::System.FormattableString.Invariant($"Failed to add frontend change to {frontend} to queue");
                    #endif
                });

            state.Clear();
        }
        public static string Sanitize(this string toSanitize) => toSanitize.ReplaceLineEndings(string.Empty);

        public static string Sanitize(this PathString toSanitize) => toSanitize.ToString().ReplaceLineEndings(string.Empty);
    }
}
